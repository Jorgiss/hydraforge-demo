<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>HydraForge â€” 3D Dam Break Simulation</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');
  :root {
    --bg: #070b14;
    --surface: #0f1724;
    --surface2: #1a2234;
    --border: #1e293b;
    --text: #e2e8f0;
    --dim: #64748b;
    --water: #06b6d4;
    --accent: #3b82f6;
    --glow: rgba(6,182,212,0.3);
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  html, body { font-family:'Inter',sans-serif; background:var(--bg); color:var(--text); overflow:hidden; height:100%; width:100%; touch-action:none; }

  #three-canvas { position:fixed; top:0; left:0; width:100%; height:100%; z-index:0; }

  /* Header */
  .header {
    position:fixed; top:0; left:0; right:0; z-index:20;
    padding:12px 16px;
    display:flex; align-items:center; justify-content:space-between;
    background:linear-gradient(180deg, rgba(7,11,20,0.95) 0%, rgba(7,11,20,0.6) 70%, transparent 100%);
  }
  .logo { display:flex; align-items:center; gap:8px; }
  .logo-icon { width:32px; height:32px; background:linear-gradient(135deg,var(--water),var(--accent)); border-radius:8px; display:flex; align-items:center; justify-content:center; font-size:16px; flex-shrink:0; }
  .logo-text { font-size:16px; font-weight:700; letter-spacing:-0.5px; white-space:nowrap; }
  .logo-text span { color:var(--water); }
  .badge { font-family:'JetBrains Mono',monospace; font-size:10px; padding:4px 10px; border-radius:6px; background:rgba(255,255,255,0.06); border:1px solid var(--border); color:var(--dim); white-space:nowrap; }

  /* Panel toggle button (mobile) */
  .panel-toggle {
    position:fixed; top:56px; right:12px; z-index:30;
    width:40px; height:40px; border-radius:10px;
    background:rgba(15,23,36,0.92); backdrop-filter:blur(16px);
    border:1px solid var(--border);
    color:var(--text); font-size:18px;
    display:none; align-items:center; justify-content:center;
    cursor:pointer; -webkit-tap-highlight-color:transparent;
  }

  /* Controls panel */
  .panel {
    position:fixed; top:56px; right:12px; width:280px; z-index:20;
    background:rgba(15,23,36,0.92); backdrop-filter:blur(20px);
    border:1px solid var(--border); border-radius:14px;
    padding:20px;
    max-height:calc(100vh - 72px); overflow-y:auto;
    transition: transform 0.3s ease, opacity 0.3s ease;
  }
  .panel h3 { font-size:11px; font-weight:600; text-transform:uppercase; letter-spacing:0.8px; color:var(--dim); margin-bottom:12px; }
  .param { margin-bottom:12px; }
  .param-header { display:flex; justify-content:space-between; margin-bottom:4px; }
  .param label { font-size:12px; font-weight:500; }
  .param-val { font-family:'JetBrains Mono',monospace; font-size:11px; color:var(--water); }
  input[type="range"] { -webkit-appearance:none; width:100%; height:6px; border-radius:3px; background:var(--border); outline:none; }
  input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none; width:20px; height:20px; border-radius:50%; background:var(--water); cursor:pointer; border:2px solid var(--bg); box-shadow:0 0 8px var(--glow); }

  .btn-row { display:flex; gap:8px; margin-bottom:14px; }
  .btn { font-family:'Inter',sans-serif; font-size:13px; font-weight:500; padding:10px 14px; border-radius:8px; border:1px solid var(--border); background:rgba(255,255,255,0.04); color:var(--text); cursor:pointer; transition:all 0.15s; flex:1; text-align:center; -webkit-tap-highlight-color:transparent; }
  .btn:hover { background:rgba(255,255,255,0.08); border-color:var(--water); }
  .btn:active { background:rgba(255,255,255,0.12); transform:scale(0.97); }
  .btn.primary { background:var(--accent); border-color:var(--accent); }
  .btn.primary:hover { background:#2563eb; }

  .divider { height:1px; background:var(--border); margin:14px 0; }

  .eq-box { font-family:'JetBrains Mono',monospace; font-size:11px; line-height:1.8; padding:12px; background:rgba(0,0,0,0.3); border-radius:8px; border:1px solid var(--border); color:var(--dim); }
  .eq-box .eq { color:var(--water); }

  /* Bottom HUD */
  .hud {
    position:fixed; bottom:12px; left:0; right:0; z-index:20;
    display:flex; gap:8px; justify-content:center;
    padding:0 12px;
    overflow-x:auto; -webkit-overflow-scrolling:touch;
    scrollbar-width:none;
  }
  .hud::-webkit-scrollbar { display:none; }
  .hud-card {
    background:rgba(15,23,36,0.9); backdrop-filter:blur(16px);
    border:1px solid var(--border); border-radius:10px;
    padding:8px 12px; min-width:90px; text-align:center;
    flex-shrink:0;
  }
  .hud-label { font-size:8px; font-weight:600; text-transform:uppercase; letter-spacing:0.7px; color:var(--dim); margin-bottom:2px; }
  .hud-value { font-family:'JetBrains Mono',monospace; font-size:15px; font-weight:600; }
  .hud-unit { font-size:9px; color:var(--dim); }

  /* Mobile floating action buttons (when panel is hidden) */
  .mobile-actions {
    position:fixed; bottom:80px; left:50%; transform:translateX(-50%); z-index:25;
    display:none; gap:10px;
  }
  .mobile-actions .btn {
    padding:12px 24px; font-size:14px; border-radius:12px;
    background:rgba(15,23,36,0.92); backdrop-filter:blur(16px);
    box-shadow:0 4px 20px rgba(0,0,0,0.4);
  }
  .mobile-actions .btn.primary {
    background:var(--accent);
    box-shadow:0 4px 20px rgba(59,130,246,0.3);
  }

  /* Info tag */
  .info-tag {
    position:fixed; bottom:12px; right:12px; z-index:20;
    font-size:9px; color:var(--dim);
    font-family:'JetBrains Mono',monospace;
  }

  /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
     Mobile Responsive
     â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
  @media (max-width: 768px) {
    .header {
      padding:10px 12px;
    }
    .badge { display:none; }
    .logo-icon { width:28px; height:28px; font-size:14px; border-radius:7px; }
    .logo-text { font-size:15px; }

    .panel-toggle { display:flex; }

    .panel {
      position:fixed;
      top:auto; bottom:0; left:0; right:0;
      width:100%; max-width:100%;
      border-radius:18px 18px 0 0;
      max-height:65vh;
      padding:20px 16px;
      transform:translateY(100%);
      opacity:0;
      pointer-events:none;
    }
    .panel.open {
      transform:translateY(0);
      opacity:1;
      pointer-events:auto;
    }

    .mobile-actions { display:flex; }

    .hud {
      bottom:8px;
      justify-content:flex-start;
      padding:0 8px;
    }
    .hud-card {
      padding:6px 10px; min-width:76px;
    }
    .hud-label { font-size:7px; }
    .hud-value { font-size:13px; }
    .hud-unit { font-size:8px; }

    .info-tag { display:none; }

    /* Bigger touch targets for sliders */
    input[type="range"] { height:8px; }
    input[type="range"]::-webkit-slider-thumb { width:24px; height:24px; }
  }

  @media (max-width: 380px) {
    .hud-card { padding:5px 8px; min-width:66px; }
    .hud-value { font-size:12px; }
    .mobile-actions .btn { padding:10px 18px; font-size:13px; }
  }

  /* Panel backdrop overlay on mobile */
  .panel-backdrop {
    position:fixed; top:0; left:0; right:0; bottom:0;
    background:rgba(0,0,0,0.5);
    z-index:15; display:none;
    -webkit-tap-highlight-color:transparent;
  }
  .panel-backdrop.show {
    display:block;
  }
</style>
</head>
<body>

<canvas id="three-canvas"></canvas>

<div class="header">
  <div class="logo">
    <div class="logo-icon">ğŸŒŠ</div>
    <div class="logo-text">Hydra<span>Forge</span></div>
  </div>
  <div class="badge">3D SIMULATION Â· Classical 1D Dam Break</div>
</div>

<!-- Mobile: toggle button for panel -->
<button class="panel-toggle" id="panel-toggle" onclick="togglePanel()">âš™</button>

<!-- Backdrop for mobile panel -->
<div class="panel-backdrop" id="panel-backdrop" onclick="closePanel()"></div>

<div class="panel" id="panel">
  <h3>Controls</h3>
  <div class="btn-row">
    <button class="btn primary" id="btn-play-panel" onclick="togglePlay()">â–¶ Run</button>
    <button class="btn" onclick="resetSim()">â†º Reset</button>
  </div>

  <h3>Parameters</h3>
  <div class="param">
    <div class="param-header"><label>Left height hâ‚</label><span class="param-val" id="pv-hl">0.020 m</span></div>
    <input type="range" id="p-hl" min="0.005" max="0.060" step="0.001" value="0.020" oninput="updateParam()">
  </div>
  <div class="param">
    <div class="param-header"><label>Right height hâ‚‚</label><span class="param-val" id="pv-hr">0.010 m</span></div>
    <input type="range" id="p-hr" min="0.002" max="0.050" step="0.001" value="0.010" oninput="updateParam()">
  </div>
  <div class="param">
    <div class="param-header"><label>Grid cells Nâ‚“</label><span class="param-val" id="pv-nx">200</span></div>
    <input type="range" id="p-nx" min="50" max="500" step="10" value="200" oninput="updateParam()">
  </div>
  <div class="param">
    <div class="param-header"><label>CFL number</label><span class="param-val" id="pv-cfl">0.40</span></div>
    <input type="range" id="p-cfl" min="0.10" max="0.95" step="0.05" value="0.40" oninput="updateParam()">
  </div>
  <div class="param">
    <div class="param-header"><label>Dam position</label><span class="param-val" id="pv-dam">0.50</span></div>
    <input type="range" id="p-dam" min="0.10" max="0.90" step="0.05" value="0.50" oninput="updateParam()">
  </div>
  <div class="param">
    <div class="param-header"><label>Height scale</label><span class="param-val" id="pv-scale">80Ã—</span></div>
    <input type="range" id="p-scale" min="20" max="200" step="5" value="80" oninput="updateParam()">
  </div>

  <div class="divider"></div>
  <h3>Equations</h3>
  <div class="eq-box">
    <span class="eq">h</span><sub>t</sub> + (<span class="eq">hu</span>)<sub>x</sub> = 0<br>
    (<span class="eq">hu</span>)<sub>t</sub> + (<span class="eq">huÂ²</span> + Â½<span class="eq">ghÂ²</span>)<sub>x</sub> = 0
  </div>

  <div class="divider"></div>
  <h3>Method</h3>
  <div style="font-size:11px;color:var(--dim);line-height:1.6">
    Godunov FV Â· HLL Riemann solver<br>
    Author: K. A. Ivanova (Ksenya)
  </div>
</div>

<!-- Mobile floating action buttons -->
<div class="mobile-actions" id="mobile-actions">
  <button class="btn primary" id="btn-play-mobile" onclick="togglePlay()">â–¶ Run</button>
  <button class="btn" onclick="resetSim()">â†º Reset</button>
</div>

<div class="hud">
  <div class="hud-card">
    <div class="hud-label">Time</div>
    <div class="hud-value" id="h-time">0.000<span class="hud-unit">s</span></div>
  </div>
  <div class="hud-card">
    <div class="hud-label">Max Height</div>
    <div class="hud-value" id="h-hmax">0.020<span class="hud-unit">m</span></div>
  </div>
  <div class="hud-card">
    <div class="hud-label">Max Vel</div>
    <div class="hud-value" id="h-umax">0.000<span class="hud-unit">m/s</span></div>
  </div>
  <div class="hud-card">
    <div class="hud-label">Mass</div>
    <div class="hud-value" id="h-mass">0.015<span class="hud-unit">kg/m</span></div>
  </div>
  <div class="hud-card">
    <div class="hud-label">Iters</div>
    <div class="hud-value" id="h-iter">0</div>
  </div>
</div>

<div class="info-tag">Drag to orbit Â· Scroll to zoom</div>

<script type="importmap">
{
  "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Mobile panel toggle
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const panel = document.getElementById('panel');
const backdrop = document.getElementById('panel-backdrop');
const toggleBtn = document.getElementById('panel-toggle');
let panelOpen = false;

window.togglePanel = () => {
  panelOpen = !panelOpen;
  panel.classList.toggle('open', panelOpen);
  backdrop.classList.toggle('show', panelOpen);
  toggleBtn.textContent = panelOpen ? 'âœ•' : 'âš™';
};

window.closePanel = () => {
  panelOpen = false;
  panel.classList.remove('open');
  backdrop.classList.remove('show');
  toggleBtn.textContent = 'âš™';
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Solver (HLL/Godunov)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const G = 9.81, EPS = 1e-8;
let NX, H_L, H_R, CFL, DAM_POS, HEIGHT_SCALE;
let h, hu, dx, simTime, iteration, running = false;

function readParams() {
  H_L = +document.getElementById('p-hl').value;
  H_R = +document.getElementById('p-hr').value;
  NX = +document.getElementById('p-nx').value;
  CFL = +document.getElementById('p-cfl').value;
  DAM_POS = +document.getElementById('p-dam').value;
  HEIGHT_SCALE = +document.getElementById('p-scale').value;
}

window.updateParam = () => {
  document.getElementById('pv-hl').textContent = (+document.getElementById('p-hl').value).toFixed(3)+' m';
  document.getElementById('pv-hr').textContent = (+document.getElementById('p-hr').value).toFixed(3)+' m';
  document.getElementById('pv-nx').textContent = document.getElementById('p-nx').value;
  document.getElementById('pv-cfl').textContent = (+document.getElementById('p-cfl').value).toFixed(2);
  document.getElementById('pv-dam').textContent = (+document.getElementById('p-dam').value).toFixed(2);
  document.getElementById('pv-scale').textContent = document.getElementById('p-scale').value+'Ã—';
  HEIGHT_SCALE = +document.getElementById('p-scale').value;
};

function initSolver() {
  readParams();
  dx = 1.0 / NX;
  h = new Float64Array(NX + 2);
  hu = new Float64Array(NX + 2);
  for (let i = 0; i < NX + 2; i++) {
    h[i] = ((i - 0.5) * dx < DAM_POS) ? H_L : H_R;
    hu[i] = 0;
  }
  bc(); simTime = 0; iteration = 0;
}

function bc() {
  h[0]=h[1]; hu[0]=hu[1];
  h[NX+1]=h[NX]; hu[NX+1]=hu[NX];
}

function hll(hL,huL,hR,huR) {
  const uL=Math.abs(hL)>EPS?huL/hL:0, uR=Math.abs(hR)>EPS?huR/hR:0;
  const cL=Math.sqrt(G*Math.max(hL,0)), cR=Math.sqrt(G*Math.max(hR,0));
  const sL=Math.min(uL-cL,uR-cR), sR=Math.max(uL+cL,uR+cR);
  const fhL=huL, fhuL=hL>EPS?huL*huL/hL+.5*G*hL*hL:0;
  const fhR=huR, fhuR=hR>EPS?huR*huR/hR+.5*G*hR*hR:0;
  if(sL>=0) return [fhL,fhuL];
  if(sR<=0) return [fhR,fhuR];
  const d=sR-sL;
  return [(sR*fhL-sL*fhR+sL*sR*(hR-hL))/d, (sR*fhuL-sL*fhuR+sL*sR*(huR-huL))/d];
}

function step() {
  let sMax=EPS;
  for(let i=1;i<=NX;i++){const u=Math.abs(h[i])>EPS?Math.abs(hu[i]/h[i]):0;sMax=Math.max(sMax,u+Math.sqrt(G*Math.max(h[i],0)));}
  const dt=CFL*dx/sMax;
  const hN=new Float64Array(NX+2), huN=new Float64Array(NX+2);
  hN.set(h); huN.set(hu);
  for(let i=1;i<=NX;i++){
    const[frh,frhu]=hll(h[i],hu[i],h[i+1],hu[i+1]);
    const[flh,flhu]=hll(h[i-1],hu[i-1],h[i],hu[i]);
    hN[i]=Math.max(h[i]-dt/dx*(frh-flh),0);
    huN[i]=hu[i]-dt/dx*(frhu-flhu);
  }
  h=hN; hu=huN; bc(); simTime+=dt; iteration++;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Three.js Scene
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const canvas = document.getElementById('three-canvas');
const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: false });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 1.2;

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x070b14);
scene.fog = new THREE.FogExp2(0x070b14, 0.08);

const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);

// Mobile-optimized camera position (closer, higher angle)
const isMobile = window.innerWidth < 768;
if (isMobile) {
  camera.position.set(4, 5, 6);
  camera.fov = 55; // wider FOV for mobile
  camera.updateProjectionMatrix();
} else {
  camera.position.set(6, 4, 8);
}
camera.lookAt(0, 0, 0);

const controls = new OrbitControls(camera, canvas);
controls.enableDamping = true;
controls.dampingFactor = 0.05;
controls.target.set(0, 0.5, 0);
controls.maxPolarAngle = Math.PI * 0.48;
controls.minDistance = 2;
controls.maxDistance = 20;
// Touch improvements
controls.touches = { ONE: THREE.TOUCH.ROTATE, TWO: THREE.TOUCH.DOLLY_PAN };
controls.rotateSpeed = isMobile ? 0.6 : 1.0;

// Lights
const amb = new THREE.AmbientLight(0x1a2a4a, 0.8);
scene.add(amb);

const dir = new THREE.DirectionalLight(0xffffff, 1.5);
dir.position.set(5, 8, 3);
scene.add(dir);

const dir2 = new THREE.DirectionalLight(0x06b6d4, 0.4);
dir2.position.set(-3, 4, -5);
scene.add(dir2);

// Ground
const groundGeo = new THREE.PlaneGeometry(20, 20);
const groundMat = new THREE.MeshStandardMaterial({ color: 0x0a1628, roughness: 0.9, metalness: 0.1 });
const ground = new THREE.Mesh(groundGeo, groundMat);
ground.rotation.x = -Math.PI / 2;
ground.position.y = -0.01;
scene.add(ground);

// Grid
const grid = new THREE.GridHelper(12, 24, 0x1a2a4a, 0x111d2e);
scene.add(grid);

// Channel walls
const wallMat = new THREE.MeshStandardMaterial({ color: 0x1e293b, roughness: 0.7, metalness: 0.3, transparent: true, opacity: 0.4 });
const wallGeo = new THREE.BoxGeometry(10, 3, 0.05);
const wallL = new THREE.Mesh(wallGeo, wallMat);
wallL.position.set(0, 1.5, -1);
scene.add(wallL);
const wallR = new THREE.Mesh(wallGeo, wallMat);
wallR.position.set(0, 1.5, 1);
scene.add(wallR);

// Water surface mesh (reduced for mobile perf)
const MESH_NX = isMobile ? 120 : 200;
const MESH_NZ = isMobile ? 12 : 20;
const waterGeo = new THREE.PlaneGeometry(10, 2, MESH_NX, MESH_NZ);
waterGeo.rotateX(-Math.PI / 2);

const waterMat = new THREE.MeshPhysicalMaterial({
  color: 0x06b6d4,
  roughness: 0.1,
  metalness: 0.1,
  transmission: isMobile ? 0.3 : 0.6, // lighter transmission for mobile GPU
  thickness: 0.5,
  transparent: true,
  opacity: 0.85,
  side: THREE.DoubleSide,
  envMapIntensity: 1.0,
  clearcoat: 0.3,
  clearcoatRoughness: 0.2,
  ior: 1.33,
});

const waterMesh = new THREE.Mesh(waterGeo, waterMat);
scene.add(waterMesh);

// Water edge glow
const edgeGeo = new THREE.BufferGeometry();
const edgePositions = new Float32Array((MESH_NX + 1) * 3);
edgeGeo.setAttribute('position', new THREE.BufferAttribute(edgePositions, 3));
const edgeMat = new THREE.LineBasicMaterial({ color: 0x22d3ee, linewidth: 2 });
const edgeLine = new THREE.Line(edgeGeo, edgeMat);
scene.add(edgeLine);

// Water bottom fill
const bottomGeo = new THREE.PlaneGeometry(10, 2, MESH_NX, 1);
bottomGeo.rotateX(-Math.PI / 2);
const bottomMat = new THREE.MeshStandardMaterial({
  color: 0x0891b2, roughness: 0.5, metalness: 0.2,
  transparent: true, opacity: 0.5, side: THREE.DoubleSide,
});
const bottomMesh = new THREE.Mesh(bottomGeo, bottomMat);
scene.add(bottomMesh);

// Dam marker
const damGeo = new THREE.BoxGeometry(0.02, 4, 2);
const damMat = new THREE.MeshBasicMaterial({ color: 0xef4444, transparent: true, opacity: 0.25 });
const damMesh = new THREE.Mesh(damGeo, damMat);
scene.add(damMesh);

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Update mesh from solver
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function updateWaterMesh() {
  const pos = waterGeo.attributes.position;
  const scale = HEIGHT_SCALE || 80;
  const verts = MESH_NX + 1;
  const rows = MESH_NZ + 1;

  for (let iz = 0; iz < rows; iz++) {
    for (let ix = 0; ix < verts; ix++) {
      const idx = iz * verts + ix;
      const solverIdx = Math.min(NX, Math.max(1, Math.round((ix / MESH_NX) * NX)));
      pos.setY(idx, h[solverIdx] * scale);
    }
  }
  pos.needsUpdate = true;
  waterGeo.computeVertexNormals();

  // Edge glow
  const ep = edgeGeo.attributes.position;
  for (let ix = 0; ix <= MESH_NX; ix++) {
    const solverIdx = Math.min(NX, Math.max(1, Math.round((ix / MESH_NX) * NX)));
    const x = -5 + (ix / MESH_NX) * 10;
    ep.setXYZ(ix, x, h[solverIdx] * scale, -1);
  }
  ep.needsUpdate = true;

  // Bottom fill
  const bp = bottomGeo.attributes.position;
  const bVerts = MESH_NX + 1;
  for (let ix = 0; ix < bVerts; ix++) {
    const solverIdx = Math.min(NX, Math.max(1, Math.round((ix / MESH_NX) * NX)));
    bp.setY(ix, h[solverIdx] * scale);
    bp.setY(bVerts + ix, 0);
  }
  bp.needsUpdate = true;
  bottomGeo.computeVertexNormals();

  // Dam position
  damMesh.position.set(-5 + DAM_POS * 10, 2, 0);

  // HUD
  let maxH=0, maxU=0, mass=0;
  for(let i=1;i<=NX;i++){
    maxH=Math.max(maxH,h[i]);
    const u=Math.abs(h[i])>EPS?Math.abs(hu[i]/h[i]):0;
    maxU=Math.max(maxU,u);
    mass+=h[i]*dx;
  }
  document.getElementById('h-time').innerHTML=simTime.toFixed(3)+'<span class="hud-unit">s</span>';
  document.getElementById('h-hmax').innerHTML=maxH.toFixed(4)+'<span class="hud-unit">m</span>';
  document.getElementById('h-umax').innerHTML=maxU.toFixed(3)+'<span class="hud-unit">m/s</span>';
  document.getElementById('h-mass').innerHTML=mass.toFixed(4)+'<span class="hud-unit">kg/m</span>';
  document.getElementById('h-iter').textContent=iteration;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Animation loop
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
function animate() {
  requestAnimationFrame(animate);

  if (running && simTime < 0.5) {
    const stepsPerFrame = Math.max(1, Math.floor(NX / (isMobile ? 60 : 40)));
    for (let s = 0; s < stepsPerFrame; s++) {
      if (simTime < 0.5) step();
      else {
        running = false;
        document.getElementById('btn-play-panel').textContent = 'â–¶ Run';
        document.getElementById('btn-play-mobile').textContent = 'â–¶ Run';
        break;
      }
    }
  }

  updateWaterMesh();
  controls.update();
  renderer.render(scene, camera);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  Controls
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
window.togglePlay = () => {
  running = !running;
  const label = running ? 'â¸ Pause' : 'â–¶ Run';
  document.getElementById('btn-play-panel').textContent = label;
  document.getElementById('btn-play-mobile').textContent = label;
};

window.resetSim = () => {
  running = false;
  document.getElementById('btn-play-panel').textContent = 'â–¶ Run';
  document.getElementById('btn-play-mobile').textContent = 'â–¶ Run';
  initSolver();
};

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// Prevent pull-to-refresh on mobile
document.body.addEventListener('touchmove', (e) => {
  if (e.target === canvas || e.target === document.body) {
    e.preventDefault();
  }
}, { passive: false });

// Init
initSolver();
animate();
</script>
</body>
</html>
