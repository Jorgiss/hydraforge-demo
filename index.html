<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>HydraForge ‚Äî 3D Shallow Water Simulations</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap');
  :root {
    --bg: #0a0e17;
    --surface: #0f1724;
    --border: #1e293b;
    --text: #e2e8f0;
    --dim: #64748b;
    --water: #06b6d4;
    --accent: #3b82f6;
    --glow: rgba(6,182,212,0.3);
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  html, body { font-family:'Inter',sans-serif; background:var(--bg); color:var(--text); overflow:hidden; height:100%; width:100%; touch-action:none; }
  #three-canvas { position:fixed; top:0; left:0; width:100%; height:100%; z-index:0; }

  .header {
    position:fixed; top:0; left:0; right:0; z-index:20;
    padding:12px 16px;
    display:flex; align-items:center; justify-content:space-between;
    background:linear-gradient(180deg, rgba(10,14,23,0.95) 0%, rgba(10,14,23,0.5) 70%, transparent 100%);
  }
  .logo { display:flex; align-items:center; gap:8px; }
  .logo-icon { width:32px; height:32px; background:linear-gradient(135deg,var(--water),var(--accent)); border-radius:8px; display:flex; align-items:center; justify-content:center; font-size:16px; flex-shrink:0; }
  .logo-text { font-size:16px; font-weight:700; letter-spacing:-0.5px; white-space:nowrap; }
  .logo-text span { color:var(--water); }
  .badge { font-family:'JetBrains Mono',monospace; font-size:10px; padding:4px 10px; border-radius:6px; background:rgba(255,255,255,0.06); border:1px solid var(--border); color:var(--dim); white-space:nowrap; }

  .panel-toggle {
    position:fixed; top:56px; right:12px; z-index:30;
    width:40px; height:40px; border-radius:10px;
    background:rgba(15,23,36,0.92); backdrop-filter:blur(16px);
    border:1px solid var(--border);
    color:var(--text); font-size:18px;
    display:none; align-items:center; justify-content:center;
    cursor:pointer; -webkit-tap-highlight-color:transparent;
  }

  .panel {
    position:fixed; top:56px; right:12px; width:300px; z-index:20;
    background:rgba(15,23,36,0.92); backdrop-filter:blur(20px);
    border:1px solid var(--border); border-radius:14px;
    padding:20px;
    max-height:calc(100vh - 72px); overflow-y:auto;
    transition: transform 0.3s ease, opacity 0.3s ease;
  }
  .panel h3 { font-size:11px; font-weight:600; text-transform:uppercase; letter-spacing:0.8px; color:var(--dim); margin-bottom:12px; }
  .param { margin-bottom:12px; }
  .param-header { display:flex; justify-content:space-between; margin-bottom:4px; }
  .param label { font-size:12px; font-weight:500; }
  .param-val { font-family:'JetBrains Mono',monospace; font-size:11px; color:var(--water); }
  input[type="range"] { -webkit-appearance:none; width:100%; height:6px; border-radius:3px; background:var(--border); outline:none; }
  input[type="range"]::-webkit-slider-thumb { -webkit-appearance:none; width:20px; height:20px; border-radius:50%; background:var(--water); cursor:pointer; border:2px solid var(--bg); box-shadow:0 0 8px var(--glow); }

  .btn-row { display:flex; gap:8px; margin-bottom:14px; }
  .btn { font-family:'Inter',sans-serif; font-size:13px; font-weight:500; padding:10px 14px; border-radius:8px; border:1px solid var(--border); background:rgba(255,255,255,0.04); color:var(--text); cursor:pointer; transition:all 0.15s; flex:1; text-align:center; -webkit-tap-highlight-color:transparent; }
  .btn:hover { background:rgba(255,255,255,0.08); border-color:var(--water); }
  .btn:active { background:rgba(255,255,255,0.12); transform:scale(0.97); }
  .btn.primary { background:var(--accent); border-color:var(--accent); }
  .btn.primary:hover { background:#2563eb; }
  .btn.active { background:rgba(6,182,212,0.2); border-color:var(--water); color:var(--water); }

  .sim-selector { display:flex; gap:4px; margin-bottom:16px; flex-wrap:wrap; }
  .sim-btn { font-size:11px; padding:8px 10px; flex:1; min-width:80px; }

  .divider { height:1px; background:var(--border); margin:14px 0; }
  .eq-box { font-family:'JetBrains Mono',monospace; font-size:11px; line-height:1.8; padding:12px; background:rgba(0,0,0,0.3); border-radius:8px; border:1px solid var(--border); color:var(--dim); }
  .eq-box .eq { color:var(--water); }

  .hud {
    position:fixed; bottom:12px; left:0; right:0; z-index:20;
    display:flex; gap:8px; justify-content:center;
    padding:0 12px;
    overflow-x:auto; -webkit-overflow-scrolling:touch;
    scrollbar-width:none;
  }
  .hud::-webkit-scrollbar { display:none; }
  .hud-card {
    background:rgba(15,23,36,0.9); backdrop-filter:blur(16px);
    border:1px solid var(--border); border-radius:10px;
    padding:8px 12px; min-width:90px; text-align:center; flex-shrink:0;
  }
  .hud-label { font-size:8px; font-weight:600; text-transform:uppercase; letter-spacing:0.7px; color:var(--dim); margin-bottom:2px; }
  .hud-value { font-family:'JetBrains Mono',monospace; font-size:15px; font-weight:600; }
  .hud-unit { font-size:9px; color:var(--dim); }

  .mobile-actions {
    position:fixed; bottom:80px; left:50%; transform:translateX(-50%); z-index:25;
    display:none; gap:10px;
  }
  .mobile-actions .btn {
    padding:12px 24px; font-size:14px; border-radius:12px;
    background:rgba(15,23,36,0.92); backdrop-filter:blur(16px);
    box-shadow:0 4px 20px rgba(0,0,0,0.4);
  }
  .mobile-actions .btn.primary { background:var(--accent); box-shadow:0 4px 20px rgba(59,130,246,0.3); }

  .info-tag {
    position:fixed; bottom:12px; right:12px; z-index:20;
    font-size:9px; color:var(--dim); font-family:'JetBrains Mono',monospace;
  }

  .param-group { display:none; }
  .param-group.active { display:block; }

  @media (max-width: 768px) {
    .header { padding:10px 12px; }
    .badge { display:none; }
    .logo-icon { width:28px; height:28px; font-size:14px; border-radius:7px; }
    .logo-text { font-size:15px; }
    .panel-toggle { display:flex; }
    .panel {
      position:fixed; top:auto; bottom:0; left:0; right:0;
      width:100%; max-width:100%; border-radius:18px 18px 0 0;
      max-height:65vh; padding:20px 16px;
      transform:translateY(100%); opacity:0; pointer-events:none;
    }
    .panel.open { transform:translateY(0); opacity:1; pointer-events:auto; }
    .mobile-actions { display:flex; }
    .hud { bottom:8px; justify-content:flex-start; padding:0 8px; }
    .hud-card { padding:6px 10px; min-width:76px; }
    .hud-label { font-size:7px; } .hud-value { font-size:13px; } .hud-unit { font-size:8px; }
    .info-tag { display:none; }
    input[type="range"] { height:8px; }
    input[type="range"]::-webkit-slider-thumb { width:24px; height:24px; }
    .sim-btn { font-size:10px; padding:6px 8px; min-width:70px; }
  }
  @media (max-width: 380px) {
    .hud-card { padding:5px 8px; min-width:66px; }
    .hud-value { font-size:12px; }
    .mobile-actions .btn { padding:10px 18px; font-size:13px; }
  }
  .panel-backdrop {
    position:fixed; top:0; left:0; right:0; bottom:0;
    background:rgba(0,0,0,0.5); z-index:15; display:none;
    -webkit-tap-highlight-color:transparent;
  }
  .panel-backdrop.show { display:block; }
</style>
</head>
<body>
<canvas id="three-canvas"></canvas>

<div class="header">
  <div class="logo">
    <div class="logo-icon">üåä</div>
    <div class="logo-text">Hydra<span>Forge</span></div>
  </div>
  <div class="badge" id="header-badge">SHALLOW WATER EQUATIONS ¬∑ 1D Dam Break ¬∑ Godunov FV</div>
</div>

<button class="panel-toggle" id="panel-toggle" onclick="togglePanel()">‚öô</button>
<div class="panel-backdrop" id="panel-backdrop" onclick="closePanel()"></div>

<div class="panel" id="panel">
  <h3>Simulation Type</h3>
  <div class="sim-selector">
    <button class="btn sim-btn active" id="btn-dam" onclick="setSimType('dam')">Dam Break</button>
    <button class="btn sim-btn" id="btn-roll" onclick="setSimType('roll')">Roll Waves</button>
    <button class="btn sim-btn" id="btn-jump" onclick="setSimType('jump')">Hydraulic Jump</button>
  </div>

  <h3>Controls</h3>
  <div class="btn-row">
    <button class="btn primary" id="btn-play-panel" onclick="togglePlay()">‚ñ∂ Run</button>
    <button class="btn" onclick="resetSim()">‚Ü∫ Reset</button>
  </div>

  <!-- Dam Break Parameters -->
  <div class="param-group active" id="params-dam">
    <h3>Parameters</h3>
    <div class="param">
      <div class="param-header"><label>Left height h‚ÇÅ</label><span class="param-val" id="pv-hl">0.020 m</span></div>
      <input type="range" id="p-hl" min="0.005" max="0.060" step="0.001" value="0.020" oninput="updateParam()">
    </div>
    <div class="param">
      <div class="param-header"><label>Right height h‚ÇÇ</label><span class="param-val" id="pv-hr">0.010 m</span></div>
      <input type="range" id="p-hr" min="0.002" max="0.050" step="0.001" value="0.010" oninput="updateParam()">
    </div>
    <div class="param">
      <div class="param-header"><label>Dam position</label><span class="param-val" id="pv-dam">0.50</span></div>
      <input type="range" id="p-dam" min="0.10" max="0.90" step="0.05" value="0.50" oninput="updateParam()">
    </div>
  </div>

  <!-- Roll Waves Parameters -->
  <div class="param-group" id="params-roll">
    <h3>Parameters</h3>
    <div class="param">
      <div class="param-header"><label>Base height h‚ÇÄ</label><span class="param-val" id="pv-h0">0.008 m</span></div>
      <input type="range" id="p-h0" min="0.003" max="0.020" step="0.001" value="0.008" oninput="updateParam()">
    </div>
    <div class="param">
      <div class="param-header"><label>Channel slope Œ∏</label><span class="param-val" id="pv-theta">0.050</span></div>
      <input type="range" id="p-theta" min="0.010" max="0.150" step="0.005" value="0.050" oninput="updateParam()">
    </div>
    <div class="param">
      <div class="param-header"><label>Friction coeff.</label><span class="param-val" id="pv-fric">0.036</span></div>
      <input type="range" id="p-fric" min="0.010" max="0.100" step="0.002" value="0.036" oninput="updateParam()">
    </div>
    <div class="param">
      <div class="param-header"><label>Perturbation a</label><span class="param-val" id="pv-pert">0.050</span></div>
      <input type="range" id="p-pert" min="0.000" max="0.200" step="0.005" value="0.050" oninput="updateParam()">
    </div>
    <div class="param">
      <div class="param-header"><label>Frequency œâ</label><span class="param-val" id="pv-omega">6.73</span></div>
      <input type="range" id="p-omega" min="1.00" max="15.00" step="0.25" value="6.73" oninput="updateParam()">
    </div>
  </div>

  <!-- Hydraulic Jump Parameters -->
  <div class="param-group" id="params-jump">
    <h3>Parameters</h3>
    <div class="param">
      <div class="param-header"><label>Upstream height h‚ÇÅ</label><span class="param-val" id="pv-jh1">0.008 m</span></div>
      <input type="range" id="p-jh1" min="0.003" max="0.020" step="0.001" value="0.008" oninput="updateParam()">
    </div>
    <div class="param">
      <div class="param-header"><label>Downstream height h‚ÇÇ</label><span class="param-val" id="pv-jh2">0.025 m</span></div>
      <input type="range" id="p-jh2" min="0.010" max="0.060" step="0.001" value="0.025" oninput="updateParam()">
    </div>
    <div class="param">
      <div class="param-header"><label>Jump position</label><span class="param-val" id="pv-jpos">0.30</span></div>
      <input type="range" id="p-jpos" min="0.10" max="0.70" step="0.05" value="0.30" oninput="updateParam()">
    </div>
    <div class="param">
      <div class="param-header"><label>Inflow velocity</label><span class="param-val" id="pv-jvel">0.50</span></div>
      <input type="range" id="p-jvel" min="0.20" max="1.50" step="0.05" value="0.50" oninput="updateParam()">
    </div>
  </div>

  <!-- Common Parameters -->
  <div class="param">
    <div class="param-header"><label>Grid cells N‚Çì</label><span class="param-val" id="pv-nx">200</span></div>
    <input type="range" id="p-nx" min="50" max="500" step="10" value="200" oninput="updateParam()">
  </div>
  <div class="param">
    <div class="param-header"><label>CFL number</label><span class="param-val" id="pv-cfl">0.40</span></div>
    <input type="range" id="p-cfl" min="0.10" max="0.95" step="0.05" value="0.40" oninput="updateParam()">
  </div>
  <div class="param">
    <div class="param-header"><label>Height scale</label><span class="param-val" id="pv-scale">80√ó</span></div>
    <input type="range" id="p-scale" min="20" max="200" step="5" value="80" oninput="updateParam()">
  </div>

  <div class="divider"></div>
  <h3>Governing Equations</h3>
  <div class="eq-box" id="eq-box">
    <span class="eq">‚àÇh/‚àÇt</span> + <span class="eq">‚àÇ(hu)/‚àÇx</span> = 0<br>
    <span class="eq">‚àÇ(hu)/‚àÇt</span> + <span class="eq">‚àÇ(hu¬≤ + ¬Ωgh¬≤)/‚àÇx</span> = 0
  </div>
  <div class="divider"></div>
  <h3>Method</h3>
  <div style="font-size:11px;color:var(--dim);line-height:1.6">
    Godunov finite volume ¬∑ HLL Riemann solver<br>
    Adaptive CFL timestep ¬∑ Variable BCs<br><br>
    <span style="color:var(--text)">Author: K. A. Ivanova</span>
  </div>
</div>

<div class="mobile-actions" id="mobile-actions">
  <button class="btn primary" id="btn-play-mobile" onclick="togglePlay()">‚ñ∂ Run</button>
  <button class="btn" onclick="resetSim()">‚Ü∫ Reset</button>
</div>

<div class="hud">
  <div class="hud-card"><div class="hud-label">Time</div><div class="hud-value" id="h-time">0.000<span class="hud-unit">s</span></div></div>
  <div class="hud-card"><div class="hud-label">Max Height</div><div class="hud-value" id="h-hmax">0.020<span class="hud-unit">m</span></div></div>
  <div class="hud-card"><div class="hud-label">Max Vel</div><div class="hud-value" id="h-umax">0.000<span class="hud-unit">m/s</span></div></div>
  <div class="hud-card"><div class="hud-label" id="h-mass-label">Mass</div><div class="hud-value" id="h-mass">0.015<span class="hud-unit">kg/m</span></div></div>
  <div class="hud-card"><div class="hud-label">Steps</div><div class="hud-value" id="h-iter">0</div></div>
</div>

<div class="info-tag">Drag to orbit ¬∑ Scroll to zoom</div>

<script type="importmap">
{ "imports": {
    "three": "https://cdn.jsdelivr.net/npm/three@0.170.0/build/three.module.js",
    "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.170.0/examples/jsm/"
}}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

// ‚îÄ‚îÄ Panel toggle ‚îÄ‚îÄ
const panelEl = document.getElementById('panel');
const backdrop = document.getElementById('panel-backdrop');
const toggleBtn = document.getElementById('panel-toggle');
let panelOpen = false;
window.togglePanel = () => { panelOpen=!panelOpen; panelEl.classList.toggle('open',panelOpen); backdrop.classList.toggle('show',panelOpen); toggleBtn.textContent=panelOpen?'‚úï':'‚öô'; };
window.closePanel = () => { panelOpen=false; panelEl.classList.remove('open'); backdrop.classList.remove('show'); toggleBtn.textContent='‚öô'; };

// ‚îÄ‚îÄ Simulation Types ‚îÄ‚îÄ
const SIM_TYPES = { DAM: 'dam', ROLL: 'roll', JUMP: 'jump' };
let currentSimType = SIM_TYPES.DAM;

// ‚îÄ‚îÄ Physics Constants ‚îÄ‚îÄ
const G=9.81, EPS=1e-8;

// ‚îÄ‚îÄ Simulation State ‚îÄ‚îÄ
let NX, CFL, HEIGHT_SCALE;
let h, hu, dx, simTime, iteration, running=false;

// Dam Break params
let H_L, H_R, DAM_POS;

// Roll Waves params (Kseniya Ivanova's solver)
let H_0, THETA, FRICTION_COEF, PERT_AMP, OMEGA;
let baseVelocity, baseDischarge;

// Hydraulic Jump params
let JH_1, JH_2, JUMP_POS, JUMP_VEL;

// ‚îÄ‚îÄ Boundary Condition Types ‚îÄ‚îÄ
const BC_TYPES = {
  ABSORBING: 0,    // Transmissive (outflow)
  PERIODIC_INFLOW: 1,  // Time-varying inflow
  FIXED_INFLOW: 2  // Constant inflow
};

function readParams(){
  NX=+document.getElementById('p-nx').value;
  CFL=+document.getElementById('p-cfl').value;
  HEIGHT_SCALE=+document.getElementById('p-scale').value;

  // Dam Break
  H_L=+document.getElementById('p-hl').value;
  H_R=+document.getElementById('p-hr').value;
  DAM_POS=+document.getElementById('p-dam').value;

  // Roll Waves
  H_0=+document.getElementById('p-h0').value;
  THETA=+document.getElementById('p-theta').value;
  FRICTION_COEF=+document.getElementById('p-fric').value;
  PERT_AMP=+document.getElementById('p-pert').value;
  OMEGA=+document.getElementById('p-omega').value;

  // Calculate derived Roll Waves parameters
  baseVelocity = Math.sqrt(G * H_0 * Math.sin(THETA) / FRICTION_COEF);
  baseDischarge = H_0 * baseVelocity;

  // Hydraulic Jump
  JH_1=+document.getElementById('p-jh1').value;
  JH_2=+document.getElementById('p-jh2').value;
  JUMP_POS=+document.getElementById('p-jpos').value;
  JUMP_VEL=+document.getElementById('p-jvel').value;
}

window.updateParam=()=>{
  // Update displayed values
  document.getElementById('pv-hl').textContent=(+document.getElementById('p-hl').value).toFixed(3)+' m';
  document.getElementById('pv-hr').textContent=(+document.getElementById('p-hr').value).toFixed(3)+' m';
  document.getElementById('pv-dam').textContent=(+document.getElementById('p-dam').value).toFixed(2);

  document.getElementById('pv-h0').textContent=(+document.getElementById('p-h0').value).toFixed(3)+' m';
  document.getElementById('pv-theta').textContent=(+document.getElementById('p-theta').value).toFixed(3);
  document.getElementById('pv-fric').textContent=(+document.getElementById('p-fric').value).toFixed(3);
  document.getElementById('pv-pert').textContent=(+document.getElementById('p-pert').value).toFixed(3);
  document.getElementById('pv-omega').textContent=(+document.getElementById('p-omega').value).toFixed(2);

  document.getElementById('pv-jh1').textContent=(+document.getElementById('p-jh1').value).toFixed(3)+' m';
  document.getElementById('pv-jh2').textContent=(+document.getElementById('p-jh2').value).toFixed(3)+' m';
  document.getElementById('pv-jpos').textContent=(+document.getElementById('p-jpos').value).toFixed(2);
  document.getElementById('pv-jvel').textContent=(+document.getElementById('p-jvel').value).toFixed(2);

  document.getElementById('pv-nx').textContent=document.getElementById('p-nx').value;
  document.getElementById('pv-cfl').textContent=(+document.getElementById('p-cfl').value).toFixed(2);
  document.getElementById('pv-scale').textContent=document.getElementById('p-scale').value+'√ó';

  HEIGHT_SCALE=+document.getElementById('p-scale').value;
  readParams(); // Recalculate derived values
};

// ‚îÄ‚îÄ Boundary Conditions ‚îÄ‚îÄ
function applyBoundaryConditions(){
  switch(currentSimType){
    case SIM_TYPES.DAM:
      // Absorbing BC on both sides (transmissive)
      h[0]=h[1]; hu[0]=hu[1];
      h[NX+1]=h[NX]; hu[NX+1]=hu[NX];
      break;

    case SIM_TYPES.ROLL:
      // Periodic inflow on left, absorbing on right
      // Left BC: h[0] = h_0 * (1.0 + a * sin(omega * t))
      const perturbation = 1.0 + PERT_AMP * Math.sin(OMEGA * simTime);
      h[0] = H_0 * perturbation;
      hu[0] = baseDischarge; // Constant discharge Q = h_0 * u_0

      // Right boundary: absorbing (transmissive)
      h[NX+1]=h[NX]; hu[NX+1]=hu[NX];
      break;

    case SIM_TYPES.JUMP:
      // Fixed inflow on left, absorbing on right
      h[0] = JH_1;
      hu[0] = JH_1 * JUMP_VEL;

      // Right boundary: absorbing
      h[NX+1]=h[NX]; hu[NX+1]=hu[NX];
      break;
  }
}

function initSolver(){
  readParams();
  dx=10.0/NX; // Domain is [-5, 5] = 10m
  h=new Float64Array(NX+2);
  hu=new Float64Array(NX+2);

  // Initialize based on simulation type
  switch(currentSimType){
    case SIM_TYPES.DAM:
      for(let i=0;i<NX+2;i++){
        const x = -5 + (i-0.5)*dx;
        h[i] = (x < -5 + DAM_POS*10) ? H_L : H_R;
        hu[i] = 0;
      }
      break;

    case SIM_TYPES.ROLL:
      // Uniform initial condition with small perturbation
      for(let i=0;i<NX+2;i++){
        h[i] = H_0 * (1.0 + 0.01 * Math.sin(2*Math.PI*i/NX));
        hu[i] = baseDischarge;
      }
      break;

    case SIM_TYPES.JUMP:
      // Higher on right (downstream), lower on left (upstream with velocity)
      for(let i=0;i<NX+2;i++){
        const x = -5 + (i-0.5)*dx;
        if(x < -5 + JUMP_POS*10){
          h[i] = JH_1;
          hu[i] = JH_1 * JUMP_VEL;
        } else {
          h[i] = JH_2;
          hu[i] = 0;
        }
      }
      break;
  }

  applyBoundaryConditions();
  simTime=0;
  iteration=0;
}

function hll(hL,huL,hR,huR){
  const uL=Math.abs(hL)>EPS?huL/hL:0,uR=Math.abs(hR)>EPS?huR/hR:0;
  const cL=Math.sqrt(G*Math.max(hL,0)),cR=Math.sqrt(G*Math.max(hR,0));
  const sL=Math.min(uL-cL,uR-cR),sR=Math.max(uL+cL,uR+cR);
  const fhL=huL,fhuL=hL>EPS?huL*huL/hL+.5*G*hL*hL:0;
  const fhR=huR,fhuR=hR>EPS?huR*huR/hR+.5*G*hR*hR:0;
  if(sL>=0)return[fhL,fhuL]; if(sR<=0)return[fhR,fhuR];
  const d=sR-sL;
  return[(sR*fhL-sL*fhR+sL*sR*(hR-hL))/d,(sR*fhuL-sL*fhuR+sL*sR*(huR-huL))/d];
}

function step(){
  let sMax=EPS;
  for(let i=0;i<=NX+1;i++){
    const u=Math.abs(h[i])>EPS?Math.abs(hu[i]/h[i]):0;
    sMax=Math.max(sMax,u+Math.sqrt(G*Math.max(h[i],0)));
  }

  const dt=CFL*dx/sMax;
  const hN=new Float64Array(NX+2),huN=new Float64Array(NX+2);

  // First update interior cells
  for(let i=1;i<=NX;i++){
    const[frh,frhu]=hll(h[i],hu[i],h[i+1],hu[i+1]);
    const[flh,flhu]=hll(h[i-1],hu[i-1],h[i],hu[i]);

    // Source terms for Roll Waves (gravity + friction)
    let source_hu = 0;
    if(currentSimType === SIM_TYPES.ROLL){
      const u = Math.abs(h[i])>EPS ? hu[i]/h[i] : 0;
      const friction = FRICTION_COEF * u * Math.abs(u) / h[i];
      const gravity = G * THETA;
      source_hu = gravity - friction;
    }

    hN[i]=Math.max(h[i]-dt/dx*(frh-flh),0);
    huN[i]=hu[i]-dt/dx*(frhu-flhu) + dt*source_hu;
  }

  h=hN;hu=huN;
  applyBoundaryConditions();
  simTime+=dt;
  iteration++;
}

// ‚îÄ‚îÄ Simulation Type Switching ‚îÄ‚îÄ
window.setSimType=(type)=>{
  currentSimType = type;

  // Update UI buttons
  document.getElementById('btn-dam').classList.toggle('active', type===SIM_TYPES.DAM);
  document.getElementById('btn-roll').classList.toggle('active', type===SIM_TYPES.ROLL);
  document.getElementById('btn-jump').classList.toggle('active', type===SIM_TYPES.JUMP);

  // Show/hide parameter groups
  document.getElementById('params-dam').classList.toggle('active', type===SIM_TYPES.DAM);
  document.getElementById('params-roll').classList.toggle('active', type===SIM_TYPES.ROLL);
  document.getElementById('params-jump').classList.toggle('active', type===SIM_TYPES.JUMP);

  // Update header badge
  const badges = {
    [SIM_TYPES.DAM]: 'SHALLOW WATER EQUATIONS ¬∑ 1D Dam Break ¬∑ Godunov FV',
    [SIM_TYPES.ROLL]: 'SHALLOW WATER EQUATIONS ¬∑ Roll Waves ¬∑ Periodic Inflow BC',
    [SIM_TYPES.JUMP]: 'SHALLOW WATER EQUATIONS ¬∑ Hydraulic Jump ¬∑ Sub/Super Transition'
  };
  document.getElementById('header-badge').textContent = badges[type];

  // Update equations display
  const eqBoxes = {
    [SIM_TYPES.DAM]: `<span class="eq">‚àÇh/‚àÇt</span> + <span class="eq">‚àÇ(hu)/‚àÇx</span> = 0<br><span class="eq">‚àÇ(hu)/‚àÇt</span> + <span class="eq">‚àÇ(hu¬≤ + ¬Ωgh¬≤)/‚àÇx</span> = 0`,
    [SIM_TYPES.ROLL]: `<span class="eq">‚àÇh/‚àÇt</span> + <span class="eq">‚àÇ(hu)/‚àÇx</span> = 0<br><span class="eq">‚àÇ(hu)/‚àÇt</span> + <span class="eq">‚àÇ(hu¬≤ + ¬Ωgh¬≤)/‚àÇx</span> = <span class="eq">ghŒ∏ - C_f u|u|/h</span>`,
    [SIM_TYPES.JUMP]: `<span class="eq">‚àÇh/‚àÇt</span> + <span class="eq">‚àÇ(hu)/‚àÇx</span> = 0<br><span class="eq">‚àÇ(hu)/‚àÇt</span> + <span class="eq">‚àÇ(hu¬≤ + ¬Ωgh¬≤)/‚àÇx</span> = 0<br><span class="eq">Fr‚ÇÅ > 1 ‚Üí Fr‚ÇÇ < 1</span>`
  };
  document.getElementById('eq-box').innerHTML = eqBoxes[type];

  // Update HUD label
  document.getElementById('h-mass-label').textContent = type===SIM_TYPES.ROLL ? 'Discharge' : 'Mass';

  // Update camera position for simulation type
  updateCameraForSimType();

  // Reset simulation
  running = false;
  document.getElementById('btn-play-panel').textContent = '‚ñ∂ Run';
  document.getElementById('btn-play-mobile').textContent = '‚ñ∂ Run';
  initSolver();
  updateDamLine();
  updateWaterMaterial();
};

function updateCameraForSimType(){
  const isMobile = window.innerWidth < 768;
  const duration = 1000;
  const startPos = camera.position.clone();
  const startTarget = controls.target.clone();

  let endPos, endTarget;

  switch(currentSimType){
    case SIM_TYPES.DAM:
      endPos = new THREE.Vector3(isMobile?3:5, isMobile?4:3, isMobile?5:6.5);
      endTarget = new THREE.Vector3(0, 0.6, 0);
      break;
    case SIM_TYPES.ROLL:
      // Lower angle for better wave viewing
      endPos = new THREE.Vector3(isMobile?2:4, isMobile?2.5:2, isMobile?6:8);
      endTarget = new THREE.Vector3(0, 0.3, 0);
      break;
    case SIM_TYPES.JUMP:
      // Side view for jump visualization
      endPos = new THREE.Vector3(isMobile?1:2, isMobile?3:2.5, isMobile?7:10);
      endTarget = new THREE.Vector3(isMobile?-1:-1.5, 0.5, 0);
      break;
  }

  // Simple animation
  const startTime = performance.now();
  function animateCamera(){
    const elapsed = performance.now() - startTime;
    const t = Math.min(elapsed/duration, 1);
    const ease = t<0.5?2*t*t:-1+(4-2*t)*t;

    camera.position.lerpVectors(startPos, endPos, ease);
    controls.target.lerpVectors(startTarget, endTarget, ease);
    controls.update();

    if(t<1) requestAnimationFrame(animateCamera);
  }
  animateCamera();
}

function updateWaterMaterial(){
  // Different color schemes for each simulation type
  switch(currentSimType){
    case SIM_TYPES.DAM:
      waterMat.color.setHex(0x0e7490);
      waterMat.attenuationColor.setHex(0x003040);
      colorDeep.setHex(0x0e5a6a);
      colorShallow.setHex(0x22d3ee);
      colorFast.setHex(0x60a5fa);
      break;
    case SIM_TYPES.ROLL:
      // Warmer tones for roll waves
      waterMat.color.setHex(0x0891b2);
      waterMat.attenuationColor.setHex(0x002840);
      colorDeep.setHex(0x0c4a5c);
      colorShallow.setHex(0x38bdf8);
      colorFast.setHex(0xa78bfa);
      break;
    case SIM_TYPES.JUMP:
      // More dramatic colors for jump
      waterMat.color.setHex(0x0d9488);
      waterMat.attenuationColor.setHex(0x002820);
      colorDeep.setHex(0x115e59);
      colorShallow.setHex(0x2dd4bf);
      colorFast.setHex(0xf472b6);
      break;
  }
}

// ‚îÄ‚îÄ Three.js ‚îÄ‚îÄ
const canvas=document.getElementById('three-canvas');
const renderer=new THREE.WebGLRenderer({canvas,antialias:true});
renderer.setSize(window.innerWidth,window.innerHeight);
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
renderer.toneMapping=THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure=1.1;

const scene=new THREE.Scene();
scene.background=new THREE.Color(0x0a0e17);
scene.fog=new THREE.FogExp2(0x0a0e17,0.025);

const camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,0.1,100);
const isMobile=window.innerWidth<768;
camera.position.set(isMobile?3:5, isMobile?4:3, isMobile?5:6.5);
if(isMobile){camera.fov=55;camera.updateProjectionMatrix();}

const controls=new OrbitControls(camera,canvas);
controls.enableDamping=true; controls.dampingFactor=0.05;
controls.target.set(0,0.6,0);
controls.maxPolarAngle=Math.PI*0.48;
controls.minDistance=2; controls.maxDistance=20;
controls.touches={ONE:THREE.TOUCH.ROTATE,TWO:THREE.TOUCH.DOLLY_PAN};
controls.rotateSpeed=isMobile?0.6:1.0;

// ‚îÄ‚îÄ Environment ‚îÄ‚îÄ
const pmrem=new THREE.PMREMGenerator(renderer);
const envScene=new THREE.Scene();
const skMat=new THREE.ShaderMaterial({
  side:THREE.BackSide,
  uniforms:{top:{value:new THREE.Color(0x0a1628)},bot:{value:new THREE.Color(0x1a3a5c)}},
  vertexShader:`varying vec3 vWP;void main(){vWP=(modelMatrix*vec4(position,1.0)).xyz;gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);}`,
  fragmentShader:`uniform vec3 top,bot;varying vec3 vWP;void main(){float h=normalize(vWP+5.0).y;gl_FragColor=vec4(mix(bot,top,pow(max(h,0.0),0.6)),1.0);}`
});
envScene.add(new THREE.Mesh(new THREE.SphereGeometry(50,16,16),skMat));
const envSpot=new THREE.Mesh(new THREE.SphereGeometry(3,8,8),new THREE.MeshBasicMaterial({color:0x6699bb}));
envSpot.position.set(10,20,8);envScene.add(envSpot);
scene.environment=pmrem.fromScene(envScene,0.04).texture;

// ‚îÄ‚îÄ Lighting ‚îÄ‚îÄ
scene.add(new THREE.AmbientLight(0x1a3050,0.8));
const sun=new THREE.DirectionalLight(0xffeedd,1.8);sun.position.set(8,12,4);scene.add(sun);
const rim=new THREE.DirectionalLight(0x06b6d4,0.3);rim.position.set(-5,3,-6);scene.add(rim);
const fill=new THREE.DirectionalLight(0x334466,0.3);fill.position.set(-3,1,5);scene.add(fill);

// ‚îÄ‚îÄ Ground plane ‚îÄ‚îÄ
const groundGeo=new THREE.PlaneGeometry(40,40);
const groundMat=new THREE.MeshStandardMaterial({color:0x0d1220,roughness:0.95,metalness:0.0});
const ground=new THREE.Mesh(groundGeo,groundMat);
ground.rotation.x=-Math.PI/2;ground.position.y=-0.01;scene.add(ground);

// ‚îÄ‚îÄ Measurement grid (subtle) ‚îÄ‚îÄ
const grid=new THREE.GridHelper(12,24,0x162030,0x111a28);
scene.add(grid);

// ‚îÄ‚îÄ Scale markers along channel ‚îÄ‚îÄ
const markerMat=new THREE.LineBasicMaterial({color:0x2a3a50,transparent:true,opacity:0.5});
for(let x=-5;x<=5;x+=1){
  const pts=[new THREE.Vector3(x,0,-1.2),new THREE.Vector3(x,0,-1.05)];
  const geo=new THREE.BufferGeometry().setFromPoints(pts);
  scene.add(new THREE.Line(geo,markerMat));
}

// ‚îÄ‚îÄ Channel edges ‚îÄ‚îÄ
const channelWidth=2.0;
const edgeLineMat=new THREE.LineBasicMaterial({color:0x2a4060,transparent:true,opacity:0.4});
function makeChannelEdge(z){
  const pts=[new THREE.Vector3(-5,0,z),new THREE.Vector3(5,0,z)];
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts),edgeLineMat));
  const pts2=[new THREE.Vector3(-5,0.05,z),new THREE.Vector3(5,0.05,z)];
  scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints(pts2),edgeLineMat));
}
makeChannelEdge(-channelWidth/2);
makeChannelEdge(channelWidth/2);

// ‚îÄ‚îÄ Feature indicator line (dam/jump) ‚îÄ‚îÄ
let damLineOpacity=1.0;
const damLineMat=new THREE.LineBasicMaterial({color:0xef4444,transparent:true,opacity:0.6});
const damLineGeo=new THREE.BufferGeometry();
const damLine=new THREE.Line(damLineGeo,damLineMat);
scene.add(damLine);

function updateDamLine(){
  let x;
  switch(currentSimType){
    case SIM_TYPES.DAM:
      x = -5 + DAM_POS*10;
      damLineMat.color.setHex(0xef4444);
      break;
    case SIM_TYPES.ROLL:
      // No dam line for roll waves
      damLineMat.opacity = 0;
      return;
    case SIM_TYPES.JUMP:
      x = -5 + JUMP_POS*10;
      damLineMat.color.setHex(0x22d3ee);
      break;
  }
  damLineMat.opacity = damLineOpacity * 0.6;
  const pts=[new THREE.Vector3(x,0,-channelWidth/2),new THREE.Vector3(x,0,channelWidth/2)];
  damLineGeo.setFromPoints(pts);
}

// ‚îÄ‚îÄ Water surface ‚îÄ‚îÄ
const MESH_NX=isMobile?120:200;
const MESH_NZ=isMobile?16:24;
const waterGeo=new THREE.PlaneGeometry(10,channelWidth,MESH_NX,MESH_NZ);
waterGeo.rotateX(-Math.PI/2);

const waterMat=new THREE.MeshPhysicalMaterial({
  color:0x0e7490,
  roughness:0.02,
  metalness:0.0,
  transmission:isMobile?0.5:0.75,
  thickness:2.0,
  transparent:true,
  opacity:0.92,
  side:THREE.DoubleSide,
  envMapIntensity:2.5,
  clearcoat:1.0,
  clearcoatRoughness:0.05,
  ior:1.33,
  attenuationColor:new THREE.Color(0x003040),
  attenuationDistance:1.5,
  specularIntensity:1.0,
  specularColor:new THREE.Color(0xffffff),
});
const waterMesh=new THREE.Mesh(waterGeo,waterMat);
scene.add(waterMesh);

// ‚îÄ‚îÄ Water volume sides ‚îÄ‚îÄ
function makeVolumeSide(zPos){
  const geo=new THREE.PlaneGeometry(10,1,MESH_NX,8);
  const mat=new THREE.MeshPhysicalMaterial({
    color:0x0a5a6a,roughness:0.05,metalness:0.0,
    transparent:true,opacity:0.6,side:THREE.DoubleSide,
    envMapIntensity:1.5,transmission:0.3,thickness:0.8,
    attenuationColor:new THREE.Color(0x002030),attenuationDistance:2.0,
  });
  const mesh=new THREE.Mesh(geo,mat);mesh.position.z=zPos;
  scene.add(mesh);
  return {mesh,geo};
}
const sideFront=makeVolumeSide(-channelWidth/2);
const sideBack=makeVolumeSide(channelWidth/2);

// ‚îÄ‚îÄ Water surface highlight line ‚îÄ‚îÄ
const hlGeo=new THREE.BufferGeometry();
const hlPos=new Float32Array((MESH_NX+1)*3);
hlGeo.setAttribute('position',new THREE.BufferAttribute(hlPos,3));
const hlMat=new THREE.LineBasicMaterial({color:0x67e8f9,transparent:true,opacity:0.35});
scene.add(new THREE.Line(hlGeo,hlMat));

const hlGeo2=new THREE.BufferGeometry();
const hlPos2=new Float32Array((MESH_NX+1)*3);
hlGeo2.setAttribute('position',new THREE.BufferAttribute(hlPos2,3));
scene.add(new THREE.Line(hlGeo2,hlMat));

// ‚îÄ‚îÄ Velocity color overlay ‚îÄ‚îÄ
const colorAttr=new Float32Array((MESH_NX+1)*(MESH_NZ+1)*3);
waterGeo.setAttribute('color',new THREE.BufferAttribute(colorAttr,3));
waterMat.vertexColors=true;

// ‚îÄ‚îÄ Color helpers ‚îÄ‚îÄ
const colorDeep=new THREE.Color(0x0e5a6a);
const colorShallow=new THREE.Color(0x22d3ee);
const colorFast=new THREE.Color(0x60a5fa);

// ‚îÄ‚îÄ Foam particles ‚îÄ‚îÄ
const FOAM_COUNT=isMobile?200:500;
const foamGeo=new THREE.BufferGeometry();
const foamPos=new Float32Array(FOAM_COUNT*3);
const foamSizes=new Float32Array(FOAM_COUNT);
const foamAlphas=new Float32Array(FOAM_COUNT);
foamGeo.setAttribute('position',new THREE.BufferAttribute(foamPos,3));
foamGeo.setAttribute('size',new THREE.BufferAttribute(foamSizes,1));
foamGeo.setAttribute('alpha',new THREE.BufferAttribute(foamAlphas,1));

const foamShaderMat=new THREE.ShaderMaterial({
  vertexShader:`attribute float size;attribute float alpha;varying float vA;void main(){vA=alpha;vec4 mv=modelViewMatrix*vec4(position,1.0);gl_PointSize=size*(150.0/-mv.z);gl_Position=projectionMatrix*mv;}`,
  fragmentShader:`varying float vA;void main(){float d=length(gl_PointCoord-0.5);if(d>0.5)discard;gl_FragColor=vec4(0.9,0.97,1.0,vA*smoothstep(0.5,0.15,d));}`,
  transparent:true,depthWrite:false,blending:THREE.AdditiveBlending,
});
scene.add(new THREE.Points(foamGeo,foamShaderMat));

const foam=[];
for(let i=0;i<FOAM_COUNT;i++)foam.push({x:0,y:-10,z:0,vx:0,vy:0,vz:0,life:0,maxLife:1,size:0.3,active:false});

function spawnFoam(x,y,z,intensity){
  const n=Math.floor(intensity*(isMobile?2:4));
  for(let c=0;c<n;c++){
    for(const p of foam){if(!p.active){
      p.x=x+(Math.random()-0.5)*0.2;p.y=y+Math.random()*0.1;
      p.z=z+(Math.random()-0.5)*channelWidth*0.7;
      p.vx=(Math.random()-0.5)*0.8;p.vy=0.3+Math.random()*1.2*intensity;
      p.vz=(Math.random()-0.5)*0.5;
      p.life=0;p.maxLife=0.4+Math.random()*0.8;p.size=0.15+Math.random()*0.3;
      p.active=true;break;
    }}
  }
}
function updateFoam(dt){
  for(let i=0;i<FOAM_COUNT;i++){
    const p=foam[i];
    if(!p.active){foamPos[i*3+1]=-10;foamAlphas[i]=0;continue;}
    p.life+=dt;
    if(p.life>=p.maxLife){p.active=false;foamAlphas[i]=0;foamPos[i*3+1]=-10;continue;}
    p.vy-=3.0*dt;p.x+=p.vx*dt;p.y+=p.vy*dt;p.z+=p.vz*dt;
    if(p.y<0){p.y=0;p.vy*=-0.15;}
    foamPos[i*3]=p.x;foamPos[i*3+1]=p.y;foamPos[i*3+2]=p.z;
    foamSizes[i]=p.size;
    const f=1-p.life/p.maxLife;foamAlphas[i]=f*f*0.5;
  }
  foamGeo.attributes.position.needsUpdate=true;
  foamGeo.attributes.size.needsUpdate=true;
  foamGeo.attributes.alpha.needsUpdate=true;
}

// ‚îÄ‚îÄ Update mesh ‚îÄ‚îÄ
function updateWaterMesh(){
  const pos=waterGeo.attributes.position;
  const col=waterGeo.attributes.color;
  const scale=HEIGHT_SCALE||80;
  const verts=MESH_NX+1,rows=MESH_NZ+1;

  // Reference height for normalization
  let refH = 0.02;
  switch(currentSimType){
    case SIM_TYPES.DAM: refH = Math.max(H_L, H_R); break;
    case SIM_TYPES.ROLL: refH = H_0 * 1.2; break;
    case SIM_TYPES.JUMP: refH = Math.max(JH_1, JH_2); break;
  }
  const maxH_L = refH * scale;

  for(let iz=0;iz<rows;iz++){
    for(let ix=0;ix<verts;ix++){
      const idx=iz*verts+ix;
      const si=Math.min(NX,Math.max(1,Math.round((ix/MESH_NX)*NX)));
      const height=h[si]*scale;

      // Subtle micro-ripple when running
      let ripple=0;
      if(running&&simTime>0.005){
        const t=performance.now()*0.002;
        const fx=ix/MESH_NX,fz=iz/MESH_NZ;
        ripple=Math.sin(fx*60+t)*Math.cos(fz*30+t*0.7)*0.008+Math.sin(fx*120-t*1.5)*0.003;
      }
      pos.setY(idx,height+ripple);

      // velocity-based color
      const vel=Math.abs(h[si])>EPS?Math.abs(hu[si]/h[si]):0;
      const hNorm=Math.min(h[si]*scale/maxH_L,1);
      const vNorm=Math.min(vel/1.5,1);
      const c=colorDeep.clone().lerp(colorShallow,1-hNorm).lerp(colorFast,vNorm*0.5);
      col.setXYZ(idx,c.r,c.g,c.b);
    }
  }
  pos.needsUpdate=true;col.needsUpdate=true;
  waterGeo.computeVertexNormals();

  // Volume sides
  for(const side of [sideFront,sideBack]){
    const sp=side.geo.attributes.position;
    const sv=MESH_NX+1,sr=9;
    for(let iy=0;iy<sr;iy++){
      for(let ix=0;ix<sv;ix++){
        const idx=iy*sv+ix;
        const si=Math.min(NX,Math.max(1,Math.round((ix/MESH_NX)*NX)));
        const topH=h[si]*scale;
        sp.setXYZ(idx,-5+(ix/MESH_NX)*10,topH*(1-iy/(sr-1)),0);
      }
    }
    sp.needsUpdate=true;side.geo.computeVertexNormals();
  }

  // Highlight lines
  for(let ix=0;ix<=MESH_NX;ix++){
    const si=Math.min(NX,Math.max(1,Math.round((ix/MESH_NX)*NX)));
    const x=-5+(ix/MESH_NX)*10;
    hlPos[ix*3]=x;hlPos[ix*3+1]=h[si]*scale;hlPos[ix*3+2]=-channelWidth/2;
    hlPos2[ix*3]=x;hlPos2[ix*3+1]=h[si]*scale;hlPos2[ix*3+2]=channelWidth/2;
  }
  hlGeo.attributes.position.needsUpdate=true;
  hlGeo2.attributes.position.needsUpdate=true;

  // Foam at steep gradients
  if(running&&simTime>0.005){
    for(let i=2;i<NX;i++){
      const grad=Math.abs(h[i+1]-h[i-1])/(2*dx);
      if(grad>0.15){
        const wx=-5+(i/NX)*10,wy=h[i]*scale;
        spawnFoam(wx,wy,0,Math.min(grad*2,3));
      }
    }
  }

  // Dam/jump line fade
  if(running&&damLineOpacity>0){
    damLineOpacity=Math.max(0,damLineOpacity-0.03);
    damLineMat.opacity=damLineOpacity*0.6;
  }

  // HUD updates
  let mxH=0,mxU=0,mass=0, discharge=0;
  for(let i=1;i<=NX;i++){
    mxH=Math.max(mxH,h[i]);
    const u=Math.abs(h[i])>EPS?Math.abs(hu[i]/h[i]):0;
    mxU=Math.max(mxU,u);
    mass+=h[i]*dx;
    discharge+=Math.abs(hu[i])*dx;
  }

  document.getElementById('h-time').innerHTML=simTime.toFixed(3)+'<span class="hud-unit">s</span>';
  document.getElementById('h-hmax').innerHTML=mxH.toFixed(4)+'<span class="hud-unit">m</span>';
  document.getElementById('h-umax').innerHTML=mxU.toFixed(3)+'<span class="hud-unit">m/s</span>';

  if(currentSimType === SIM_TYPES.ROLL){
    document.getElementById('h-mass').innerHTML=discharge.toFixed(4)+'<span class="hud-unit">m¬≤/s</span>';
  } else {
    document.getElementById('h-mass').innerHTML=mass.toFixed(4)+'<span class="hud-unit">kg/m</span>';
  }
  document.getElementById('h-iter').textContent=iteration;
}

// ‚îÄ‚îÄ Animation loop ‚îÄ‚îÄ
let lastTime=performance.now();
function animate(){
  requestAnimationFrame(animate);
  const now=performance.now(),dt=Math.min((now-lastTime)/1000,0.05);lastTime=now;

  // Run simulation steps
  if(running){
    const spf=Math.max(1,Math.floor(NX/(isMobile?60:40)));
    for(let s=0;s<spf;s++){
      step();
      if(currentSimType === SIM_TYPES.DAM && simTime >= 0.5){
        running = false;
        document.getElementById('btn-play-panel').textContent='‚ñ∂ Run';
        document.getElementById('btn-play-mobile').textContent='‚ñ∂ Run';
        break;
      }
    }
  }

  updateWaterMesh();
  updateFoam(dt);
  controls.update();
  renderer.render(scene,camera);
}

// ‚îÄ‚îÄ Controls ‚îÄ‚îÄ
window.togglePlay=()=>{
  running=!running;
  const l=running?'‚è∏ Pause':'‚ñ∂ Run';
  document.getElementById('btn-play-panel').textContent=l;
  document.getElementById('btn-play-mobile').textContent=l;
};

window.resetSim=()=>{
  running=false;
  damLineOpacity=1.0;
  damLineMat.opacity=0.6;
  for(const p of foam)p.active=false;
  document.getElementById('btn-play-panel').textContent='‚ñ∂ Run';
  document.getElementById('btn-play-mobile').textContent='‚ñ∂ Run';
  initSolver();
  updateDamLine();
};

window.addEventListener('resize',()=>{
  camera.aspect=window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth,window.innerHeight);
});

document.body.addEventListener('touchmove',(e)=>{
  if(e.target===canvas||e.target===document.body)e.preventDefault();
},{passive:false});

// Init
initSolver();
updateDamLine();
updateWaterMaterial();
animate();
</script>
</body>
</html>
